package com.wy.action.algorithm.dp;

import org.junit.Assert;
import org.junit.Test;

/**
 * @Author wangyong
 * @Date 2020-03-11
 */
public class UniquePath {



    /**
     * 动态规划算
     * @param m
     * @param n
     * @return
     */
    public int uniquePaths2(int m, int n) {
       int[][] status = new int[n][m];
       for(int i=0;i<n;i++) {//左侧都是1
           status[i][0] = 1;
       }
        for(int i=0;i<m;i++) {//上侧都是1
            status[0][i] = 1;
        }
        for(int i=1;i<n;i++) {
            for(int j=1;j<m;j++) {
                status[i][j] = status[i-1][j] + status[i][j-1];
            }
        }
        return status[n-1][m-1];
    }
    @Test
    public void test() {
        Assert.assertEquals(3,uniquePaths2(3,2));
        Assert.assertEquals(126,uniquePaths2(5,6));
    }
    /**
     * 从左上角走到右下角有多少种走法（只能向右或向下）带有障碍
     * https://leetcode.com/problems/unique-paths/
     * @param obstacleGrid
     * @return
     */
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid[0][0]==1) {
            return 0;
        }
        int n = obstacleGrid.length,m = obstacleGrid[0].length;
        int[][] status = new int[n][m];
        status[0][0] = 1;
        for(int i=1;i<n;i++) {//左侧都是1
            if(obstacleGrid[i][0] == 1 ||status[i-1][0]==0) {
                status[i][0] = 0;
            } else {
                status[i][0] = 1;
            }

        }
        for(int i=1; i<m; i++) {//上侧都是1
            if(obstacleGrid[0][i] == 1 ||status[0][i-1]==0) {
                status[0][i] = 0;
            } else {
                status[0][i] = 1;
            }
        }
        for(int i=1;i<n;i++) {
            for(int j=1;j<m;j++) {
                if (obstacleGrid[i][j] == 1) {
                    status[i][j] = 0;
                } else {
                    status[i][j] = status[i-1][j] + status[i][j-1];
                }

            }
        }
        return status[n-1][m-1];
    }

    @Test
    public void uniquePathsWithObstaclesTest() {
//        Assert.assertEquals(2,uniquePathsWithObstacles(new int[][] {
//                {0,0,0},
//                {0,1,0},
//                {0,0,0}
//        }));

        Assert.assertEquals(1637984640, uniquePathsWithObstacles(new int[][] {
                {0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0},
                {0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
                {0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0},
                {1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1},
                {0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0},
                {0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0},
                {1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0},
                {0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0},
                {0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0},
                {0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0},
                {0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0},
                {1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1},
                {0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0},
                {0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0},
                {0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1},
                {1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
                {0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0},
                {0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1},
                {0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1},
                {1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0},
                {0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1},
                {0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0}

        }));
    }


}
